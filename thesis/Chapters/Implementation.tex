% !TEX root = ../Thesis.tex
\chapter{Implementation}

The practical part of this work aims to implement the previously constructed history aware p2p set synchronization protocol in a secure way, it will be a standalone app based on SDaTaDirect. To showcase the synchronization it will provide a similar functionality as discussed in \ref{sec:the_scuttlebutt_protocol}, it will provide the same system of feeds and pubs and the possibility to dynamically add messages to feeds. The goal will be to allow a fast synchronization of these feeds and messages between two devices.

\section{Basic Functionality}

Every device has an associated feed, it gets automatically created and stored in the datbase when the app is started for the first time. In this feed the device can publish messages directly through the app. A user can also create one or more pubs, feeds that simply republish all messages in the private feeds of all devices subscribed to the pub, to subscribe to a pub, a device has to directly connect itself to the pub owner when it wants to subscribe to a pub, after that the pub messages will travel through the p2p network just like any other message in a private feed. A user can not only subscribe to a pub, but also follow private feeds of devices. The app is designed as a proof of concept for the set synchronization protocol, so the functionality of the sets themselves is kept at a minimum. To synchronize one device with another device, and thus forward all messages it has published into the network, the user simply has to securely connect to the partner through the SDataDirect protocol, as described in \ref{sec:SDataDirect}, upon a connection the two devices automatically start the synchronization, without any further user input. The synchronization is done securely by encrypting all packages with the established, peer dependent, AES key pair and signing it with the public key of the sender, as proposed by Gowthaman Gobalasingam in the SDaTaDiret protocol. 


\section{Configuring the Database}

The SDaTaDirect app already has a database set up, but because its only use was to save the previously connected peers, the data model remained quite simple, with only one table that includes all needed data. The data is organized in a Room\footnote{https://developer.android.com/jetpack/androidx/releases/room} database. To support the history awareness of the synchronization in a peer-to-peer environment, every device needs to save the state of the last synchronization with any peer locally, as discussed in \ref{sec:Data_Identification}. We created tables to support the feeds and message functionalites, extended the peer table to include the history aware elements and added a way to save which peer is interested in which feeds. in \ref{fig:ER} we can see the design of the database in the form of an ER diagram. One important difference to the original SDaTaApp is the persistent public key, the app checks on start-time if it already posseses a public key, identifying it in the network, if not it will create a key and store it in the database. In the original design, a new public key was created for every new peer. 

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.08]{"ER.png"}
	\caption{the final ER diagram of the underlying database of the app}
	\label{fig:ER}
\end{figure}

\section{Extending the GUI}

While no changes had to be made to the way devices connect to each other in the app, and therefore no additional interfaces had to be created to initialize the synchronization, the GUI needed to be changed to allow for dynamic content creation, interaction and viewing of the feeds the app has discovered. 
\\
\\
The user can visit its own feed after starting the app on the feed view, as can be seen in \ref{fig:emptyFeed}.
\clearpage
\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.1]{"feedViewEmpty.jpg"}
	\caption{The view of the feeds after the first start, with no discovered feeds or created pubs}
	\label{fig:emptyFeed}
\end{figure}
 
When the user clicks on a feed, the app opens up a view of all the messages in the feed that this device has received, if the user is allowed to publish messages in the feed (if the feed belongs to this device), a small text box allows the user to create messages that will be posted in the feed. A user can create as many pubs as they want, in which any messages, published in the private feed of the device owner, automatically will be reproduced. In \ref{fig:pub1} we can see the dialog to create a new peer, and in \ref{fig:pub2} you can see the reproduced messages that were originally published in the creators private feed, which can be seen in \ref{fig:FeedView}
\begin{figure}
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.4\linewidth]{"createPub.jpg"}
		\captionof{figure}{Creating a new pub inside the app}
		\label{fig:pub1}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.4\linewidth]{"pubView.jpg"}
		\captionof{figure}{the view inside of the newly created pub, all private messages of every subscribed device will be published here}
		\label{fig:pub2}
	\end{minipage}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[scale = 0.1]{"privateFeedMessagesPublished.jpg"}
	\caption{The interface of a feed in which the user is allowed to publish messages}
	\label{fig:FeedView}
\end{figure}

\section{Adjusting the Communication Functionalities}

The app was set up for a one-time-only data exchange, it opens a TCP socket where the client can send data to the host, after the data has successfully been transmitted, the socket closes again and the app has to be restarded to send another file. As the protocol requires two-way communication, we had to adapt the communication, the host creates a new socket for every incoming connection, with which it connects to the new client, allowing messages to go both ways. The sockets get organized in a static connection manager, from which every connected device can be reached from. A message buffer catches all messages from all sockets and conitnuosly verifies them by their signature and forwards it to the interpreter. All packages contain a payload and a signature, this all gets converted to byte arrays that are transmitted using a kotlin data output stream.

\section{Adapting the Protocol as a Kotlin Script}

As previously mentioned, the protocol was implemented as a RFC protocol, There are predefined commands that are transmitted that cause an action to be made in the partners device. Together with any additional arguments that need to be passed to the function, the method call is packed into a JSON object and transformed into a byte array, which then will be forwarded to the communication manager for encryption and signing. An overview of all available method calls can be seen in \ref{tab:methods}

\begin{table}[!h]
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|l|}
			\hline
			Method Call String            & Arguments                                                                                                                                            & Description                                                                                                                                                                                                                                                                                                          \\ \hline
			SEND\_FEED\_UPDATE            & feedKey: String, Subscribed: Boolean                                                                                                                 & \begin{tabular}[c]{@{}l@{}}Inform the partner of a subscribtion change or newly \\ discovered feed since the last synchronization\end{tabular}                                                                                                                                                                       \\ \hline
			INQUIRE\_FEED\_DETAILS        & feedKey: String                                                                                                                                      & \begin{tabular}[c]{@{}l@{}}Inquire the details of a feed in case the device hasn't \\ discovered it yet\end{tabular}                                                                                                                                                                                                 \\ \hline
			ANSWER\_FEED\_QUERY           & \begin{tabular}[c]{@{}l@{}}feedKey: String, type: String, host: String, \\ port: String, subscribed: Boolean, owner: String\end{tabular}             & \begin{tabular}[c]{@{}l@{}}Send all required details to save a new feed, the owner\\ String is a public key of another device, the type can be either\\ Pub or Private\end{tabular}                                                                                                                                  \\ \hline
			END\_PHASE\_ONE               & \textit{none}                                                                                                                                        & End the first phase of the protocol, automatically triggers phase two                                                                                                                                                                                                                                                \\ \hline
			SEND\_LAST\_SEQ\_NR           & feedKey: String, lastSeq: Long                                                                                                                       & \begin{tabular}[c]{@{}l@{}}Inform the partner, if a new message has been published in the feed\\ since the last synchronization, what the sequence number of the\\ newest available message is\end{tabular}                                                                                                          \\ \hline
			END\_PHASE\_TWO               & \textit{none}                                                                                                                                        & End the second phase of the protocol, automatically triggers phase three                                                                                                                                                                                                                                             \\ \hline
			SEND\_RANGE\_MESSAGE\_REQUEST & feedKey: String, lowerLimit: Long                                                                                                                    & \begin{tabular}[c]{@{}l@{}}Request all messages in a feed that are newer than the lower limit\\ sequence number provided\end{tabular}                                                                                                                                                                                \\ \hline
			SEND\_MESSAGE                 & \begin{tabular}[c]{@{}l@{}}sequenceNr: Long, feedKey: String, content: String, \\ publisher: String, signature: String, timestamp: Long\end{tabular} & \begin{tabular}[c]{@{}l@{}}Provide a message in a feed that the partner has not received yet, \\ the content variable is a byte array encoded to string using the UTF\_8 \\ Charset, publisher is a public key of a device, the signature can be used\\ to verify that the message has not been altered\end{tabular} \\ \hline
			SEND\_PUB\_UPDATE             & \begin{tabular}[c]{@{}l@{}}sequenceNr: Long, feedKey: String, content: String, \\ publisher: String, signature: String, timestamp: Long\end{tabular} & \begin{tabular}[c]{@{}l@{}}If one of the messages received during the sync is a message that has to be\\ published in a pub hosted by the receiver, and if the current synchronization\\ partner is subscribed to this pub, inform him of the new message that has been\\ published in the pub\end{tabular}          \\ \hline
			END\_PHASE\_THREE             & \textit{none}                                                                                                                                        & \begin{tabular}[c]{@{}l@{}}End the third phase of the protocol, automatically triggers the synchronization\\ of the lastSync variable\end{tabular}                                                                                                                                                                   \\ \hline
			SEND\_LAST\_SYNC              & lastSync: Long                                                                                                                                       & \begin{tabular}[c]{@{}l@{}}Synchronize the lastSync variable across both devices, this method\\ will only be used by the initiator of the synchronization\end{tabular}                                                                                                                                               \\ \hline
		\end{tabular}%
	}
	\caption{An overview of the available methods that can be used in this implementation of the protocol}
	\label{tab:methods}
\end{table}

The protocol is mainly implemented in the \textit{SetSynchronization.kt} file, the script is started after every new connection, and can be called programatically at any time by providing the target, the role of the invoking device (master or slave), and the starting point of the protocol (e.g. phase one to four). The file contains all methods that can be called remotely, it also contains a static Hashmap that collects all the feeds where the partner has new messages, this collection gets cycled through in phase three, and for every feed where the device is not up to date, a message range request is sent. The methods largely update or exchange data objects from the database according to the protocol, one thing that had to be changed from the general set synchronization protocol to the specific use of a Scuttlebutt like environment is the special handling of Pubs, since we still have to send updates about feeds that the partner is potentially not interested in, if the feed owner is subscribed to a pub hosted by the partner.